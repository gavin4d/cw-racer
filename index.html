<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Morse Code Checker</title>
    <!-- Removed stylesheet link -->
    <!-- Removed nav-header styles -->
    <style>
        body { font-family: sans-serif; margin: 20px; }
        .controls-container { display: flex; gap: 20px; margin-bottom: 20px; flex-wrap: wrap; }
        .settings-panel, .instructions-panel { border: 1px solid #ccc; padding: 15px; border-radius: 8px; background-color: #f9f9f9; }
        .controls { display: flex; flex-direction: column; gap: 10px; }
        .control-group { display: flex; align-items: center; gap: 10px; }
        .control-group label { min-width: 100px; text-align: right; }
        .value-display { font-weight: bold; min-width: 30px; text-align: left; }
        input[type="range"] { flex-grow: 1; }
        .container { margin-top: 20px; border: 1px solid #ddd; padding: 15px; border-radius: 8px; }
        .current-input { font-size: 1.5em; margin-top: 10px; min-height: 1.5em; background-color: #eee; padding: 10px; border-radius: 4px; }
        button { padding: 8px 15px; cursor: pointer; }

        /* Timing Display Styles */
        .timing-display-container { margin-top: 15px; padding-top: 15px; border-top: 1px solid #eee; }
        .timing-row { display: flex; align-items: center; margin-bottom: 10px; min-height: 30px; }
        .timing-label { width: 50px; font-size: 0.9em; color: #555; }
        .timing-bar { display: flex; height: 20px; border: 1px solid #ccc; background-color: #fff; overflow: hidden; width: 100%; }
        .timing-element { height: 100%; }
        .timing-key-down { background-color: #333; /* Black for key down */ }
        .timing-key-up { background-color: #eee; /* Light grey for key up */ }
        .timing-element.perfect { opacity: 0.7; }
        h1, h2 { margin-top: 0; }
    </style>
</head>
<body>
    <!-- Removed nav header -->

    <h1>Morse Code Input</h1>
    
    <div class="panels-container" style="display: flex; gap: 20px; margin-bottom: 20px; flex-wrap: wrap;">
        <div class="settings-panel">
            <h2>Settings</h2>
            <div class="controls">
                <div class="control-group">
                    <label for="mode">Keyer Mode:</label>
                    <select id="mode">
                        <option value="1">Straight Key</option>
                        <option value="2" selected>Iambic A</option>
                        <option value="3">Iambic B</option>
                        <option value="4">Ultimatic</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label for="wpm">Speed (WPM):</label>
                    <input type="range" id="wpm" min="5" max="40" value="20">
                    <span id="wpmValue" class="value-display">20</span>
                </div>
                
                <div class="control-group">
                    <label>Calculated WPM:</label>
                    <span id="calculatedWpmValue" class="value-display">--</span>
                </div>
                
                <div class="control-group">
                    <label for="farnsworth">Farnsworth:</label>
                    <input type="range" id="farnsworth" min="1" max="10" value="2">
                    <span id="farnsworthValue" class="value-display">2x</span>
                </div>
                
                <div class="control-group">
                    <label for="tone">Tone (Hz):</label>
                    <input type="range" id="tone" min="400" max="1000" value="550">
                    <span id="toneValue" class="value-display">550</span>
                </div>

                <button id="clearButton">Clear Input</button>
            </div>
        </div>

        <div class="instructions-panel">
            <h2>Keying Instructions</h2>
            <p>Use these keys to send Morse code:</p>
            <ul>
                <li>Left Ctrl or '[' - Dit (.)</li>
                <li>Right Ctrl or ']' - Dah (-)</li>
            </ul>
            <p>The pattern will be shown as you type.</p>
        </div>

        <div class="stats-panel" style="border: 1px solid #ccc; padding: 15px; border-radius: 8px; background-color: #f9f9f9;">
            <h2>Timing Stats (Last 20)</h2>
            <div class="stat-item">
                <strong>Dit (ms):</strong>
                <div>Ideal: <span id="idealDit">--</span></div>
                <div class="graph-container" id="ditGraphContainer" style="height: 100px; width: 50px; border: 1px solid #eee; position: relative; margin-top: 5px; background-color: #fff;">
                    <div class="ideal-bar" style="position: absolute; bottom: 0; left: 5px; width: 15px; background-color: lightblue;"></div>
                    <div class="actual-range-bar" style="position: absolute; left: 30px; width: 15px; background-color: rgba(255, 165, 0, 0.5);"></div>
                    <div class="actual-avg-marker" style="position: absolute; left: 28px; width: 19px; height: 2px; background-color: orange; transform: translateY(-1px);"></div>
                </div>
                <div>Actual (Avg/Min/Max): <span id="actualDit">-- / -- / --</span></div>
            </div>
            <div class="stat-item" style="margin-top: 10px;">
                <strong>Dah (ms):</strong>
                <div>Ideal: <span id="idealDah">--</span></div>
                <div class="graph-container" id="dahGraphContainer" style="height: 100px; width: 50px; border: 1px solid #eee; position: relative; margin-top: 5px; background-color: #fff;">
                    <div class="ideal-bar" style="position: absolute; bottom: 0; left: 5px; width: 15px; background-color: lightblue;"></div>
                    <div class="actual-range-bar" style="position: absolute; left: 30px; width: 15px; background-color: rgba(255, 165, 0, 0.5);"></div>
                    <div class="actual-avg-marker" style="position: absolute; left: 28px; width: 19px; height: 2px; background-color: orange; transform: translateY(-1px);"></div>
                </div>
                <div>Actual (Avg/Min/Max): <span id="actualDah">-- / -- / --</span></div>
            </div>
            <!-- Add placeholders for space stats later if needed -->
        </div>
    </div>

    <div class="container">
        <h2>Timing Comparison (Last Letter)</h2>
        <div class="timing-display-container">
            <div class="timing-row">
                <span class="timing-label">Ideal:</span>
                <div id="idealTimingDisplay" class="timing-bar"></div>
            </div>
            <div class="timing-row">
                <span class="timing-label">Actual:</span>
                <div id="actualTimingDisplay" class="timing-bar"></div>
            </div>
        </div>

        <div id="currentInput" class="current-input"></div>
    </div>

    <script src="scripts/sounder.js"></script>
    <script src="scripts/morse-tools/decoder.js"></script>
    <script src="scripts/morse-tools/keyer.js"></script>

    <script>
        let currentInput = '';

        // Initialize components
        const sounder = new Sounder();
        
        // Handler for decoded letters
        const handleDecodedLetter = (letter) => {
            currentInput += letter;
            document.getElementById('currentInput').textContent = currentInput;

            // Update WPM display first
            updateWpmDisplay(letter);

            // Only update timing display for actual characters, not spaces
            if (letter && letter.trim()) {
                const wpm = parseInt(document.getElementById('wpm').value);
                let idealTimings = [];
                let actualTimings = []; // To store measured timings
                const decodedPattern = morsePattern(letter); // Get .- pattern
                const idealElementTimings = getIdealTiming('', wpm); // Get ideal dit, dah, space times

                if (decodedPattern && idealElementTimings) {
                    let isFirstElement = true;
                    for (const element of decodedPattern) {
                        if (!isFirstElement) {
                            // Add ideal intra-character space
                            idealTimings.push({ type: 'space', duration: idealElementTimings.intraCharSpace });
                        }
                        if (element === '.') {
                            idealTimings.push({ type: 'mark', duration: idealElementTimings.dit });
                        } else if (element === '-') {
                            idealTimings.push({ type: 'mark', duration: idealElementTimings.dah });
                        }
                        isFirstElement = false;
                    }
                }

                // Get actual measured timings for the bar
                actualTimings = decoder.getLastLetterTimings();

                idealTimings = getIdealTiming(letter, wpm);

                // Draw the bars *after* reconstruction
                drawTimingBar('idealTimingDisplay', idealTimings);
                drawTimingBar('actualTimingDisplay', actualTimings); // Draw measured timings
            } else {
                // Don't clear bars on space or unknown characters, let them persist
            }

            // Update the statistics display regardless of character type
            updateStatsDisplay();
        };

        const decoder = new Decoder(handleDecodedLetter);
        const keyer = new Keyer(sounder, decoder);

        // Load settings if available
        const savedSettings = JSON.parse(localStorage.getItem('morse-settings'));
        if (savedSettings) {
            keyer.setWpm(savedSettings.wpm);
            decoder.setFarnsworth(savedSettings.farnsworth);
            sounder.setTone(savedSettings.tone);
            keyer.setMode(savedSettings.mode); // Also load mode
            document.getElementById('wpm').value = savedSettings.wpm;
            document.getElementById('farnsworth').value = savedSettings.farnsworth;
            document.getElementById('tone').value = savedSettings.tone;
            document.getElementById('mode').value = savedSettings.mode; // Set dropdown value
            updateDisplays();
        } else {
            // Ensure default mode is set if no saved settings
            keyer.setMode(parseInt(document.getElementById('mode').value));
            updateDisplays(); // Update display for initial default values
        }

        // Set up keyboard input
        window.addEventListener('keydown', (e) => keyer.press(e, true));
        window.addEventListener('keyup', (e) => keyer.press(e, false));

        // Update displays for settings
        function updateDisplays() {
            document.getElementById('wpmValue').textContent = document.getElementById('wpm').value;
            document.getElementById('farnsworthValue').textContent = document.getElementById('farnsworth').value + 'x';
            document.getElementById('toneValue').textContent = document.getElementById('tone').value;
        }

        // Save settings when changed
        function saveSettings() {
            const settings = {
                mode: parseInt(document.getElementById('mode').value),
                wpm: parseInt(document.getElementById('wpm').value),
                farnsworth: parseInt(document.getElementById('farnsworth').value),
                tone: parseInt(document.getElementById('tone').value)
            };
            localStorage.setItem('morse-settings', JSON.stringify(settings));
        }

        // Wire up settings controls
        document.getElementById('wpm').addEventListener('input', function() {
            keyer.setWpm(this.value);
            updateDisplays();
            saveSettings();
            updateStatsDisplay(); // Update ideal stats when WPM changes
        });

        document.getElementById('farnsworth').addEventListener('input', function() {
            const fwpm = parseInt(farnsworth.value);
            farnsworthValue.textContent = fwpm + 'x';
            decoder.setFarnsworth(fwpm);
            updateStatsDisplay(); // Update ideal stats (though Farnsworth mainly affects spaces)
        });

        document.getElementById('tone').addEventListener('input', () => {
            toneValue.textContent = tone.value;
            sounder.setTone(tone.value);
        });

        document.getElementById('mode').addEventListener('change', function() {
            keyer.setMode(parseInt(this.value));
            saveSettings();
        });

        // Clear button functionality
        document.getElementById('clearButton').addEventListener('click', () => {
            // Clear timing display
            document.getElementById('idealTimingDisplay').innerHTML = ''; // Clear timing bars
            document.getElementById('actualTimingDisplay').innerHTML = '';

            currentInput = '';
            document.getElementById('currentInput').textContent = '';
            document.getElementById('calculatedWpmValue').textContent = '--'; // Clear WPM display
            decoder.clearStats();
            updateStatsDisplay(); // Clear stats display
        });

        // Function to update calculated WPM display
        function updateWpmDisplay(letter) {
            const mode = parseInt(document.getElementById('mode').value);
            const setWpm = parseInt(document.getElementById('wpm').value);
            let displayWpm = '--';

            if (mode !== 1) { // Not Straight Key
                displayWpm = setWpm; // For other modes, display the set WPM
            } else {
                // For Straight Key, we need to calculate it.
                // We need timing data from the decoder for the 'letter'.
                // Let's look into how decoder.js provides this.
                const actualWpm = decoder.calculateWpm();
                displayWpm = actualWpm ? actualWpm.toFixed(1) : '--';
            }
            document.getElementById('calculatedWpmValue').textContent = displayWpm;
        }

        // --- Morse Code Data & Helpers ---
        const ditdahMap = {
            'A': '12', 'B': '2111', 'C': '2121', 'D': '211', 'E': '1', 'F': '1121', 'G': '221', 'H': '1111', 'I': '11', 'J': '1222', 'K': '212', 'L': '1211', 'M': '22', 'N': '21', 'O': '222', 'P': '1221', 'Q': '2212', 'R': '121', 'S': '111', 'T': '2', 'U': '112', 'V': '1112', 'W': '122', 'X': '2112', 'Y': '2122', 'Z': '2211',
            '1': '12222', '2': '11222', '3': '11122', '4': '11112', '5': '11111', '6': '21111', '7': '22111', '8': '22211', '9': '22221', '0': '22222',
            '/': '21121', '?': '112211', '.': '121212', ',': '221122', '=': '21112',
            // Add other characters as needed
        };

        // Convert 1s and 2s pattern to dots and dashes
        function ditDahToPattern(ditDah) {
            if (!ditDah) return '';
            return ditDah.split('').map(d => d === '1' ? '.' : '-').join('');
        }

        // Get the .- pattern for a letter
        function morsePattern(letter) {
            const upperLetter = letter.toUpperCase();
            const ditDah = ditdahMap[upperLetter];
            return ditDahToPattern(ditDah);
        }

        // --- Statistics Update Function ---
        let idealDitSpan, actualDitSpan, idealDahSpan, actualDahSpan;
        let ditGraphContainer, dahGraphContainer; // Add graph containers

        // --- Stat Graph Update Function ---
        const maxMsForGraph = 400; // e.g., 400ms maps to 100px height
        function updateStatGraph(containerId, idealMs, stats) {
            const container = document.getElementById(containerId);
            if (!container) return;

            const idealBar = container.querySelector('.ideal-bar');
            const actualRangeBar = container.querySelector('.actual-range-bar');
            const actualAvgMarker = container.querySelector('.actual-avg-marker');

            const containerHeight = container.clientHeight; // e.g., 100px
            const scale = containerHeight / maxMsForGraph;

            // Helper to calculate scaled height/position, capping at container height
            const getPixels = (ms) => Math.min(containerHeight, Math.max(0, ms * scale));

            // Update Ideal Bar
            if (idealBar && !isNaN(idealMs)) {
                idealBar.style.height = `${getPixels(idealMs)}px`;
            } else if (idealBar) {
                idealBar.style.height = `0px`;
            }

            // Update Actual Range Bar and Avg Marker
            if (actualRangeBar && actualAvgMarker && stats && !isNaN(stats.min) && !isNaN(stats.max) && !isNaN(stats.avg)) {
                const minPx = getPixels(stats.min);
                const maxPx = getPixels(stats.max);
                const avgPx = getPixels(stats.avg);

                actualRangeBar.style.bottom = `${minPx}px`;
                actualRangeBar.style.height = `${Math.max(1, maxPx - minPx)}px`; // Ensure at least 1px height
                actualAvgMarker.style.bottom = `${avgPx - 1}px`; // -1 because marker has height 2

                actualRangeBar.style.display = 'block';
                actualAvgMarker.style.display = 'block';
            } else if (actualRangeBar && actualAvgMarker) {
                // Hide if stats are invalid
                actualRangeBar.style.display = 'none';
                actualAvgMarker.style.display = 'none';
            }
        }

        function updateStatsDisplay() {
            const currentWpm = parseInt(document.getElementById('wpm').value);
            const idealTimings = getIdealTiming('', currentWpm); // Get ideal dit/dah times

            idealDitSpan = document.getElementById('idealDit');
            actualDitSpan = document.getElementById('actualDit');
            ditGraphContainer = document.getElementById('ditGraphContainer'); // Assign graph container
            idealDahSpan = document.getElementById('idealDah');
            actualDahSpan = document.getElementById('actualDah');
            dahGraphContainer = document.getElementById('dahGraphContainer'); // Assign graph container

            // Calculate ideal times
            const idealDit = idealTimings.dit;
            const idealDah = idealTimings.dah;

            // Update text displays
            idealDitSpan.textContent = idealDit.toFixed(0);
            idealDahSpan.textContent = idealDah.toFixed(0);

            // Get Dit stats
            const ditStats = decoder.getStats('dit');
            if (ditStats && !isNaN(ditStats.avg)) {
                actualDitSpan.textContent = `${ditStats.avg} / ${ditStats.min} / ${ditStats.max}`;
            } else {
                actualDitSpan.textContent = `-- / -- / --`;
            }

            // Get Dah stats
            const dahStats = decoder.getStats('dah');
            if (dahStats && !isNaN(dahStats.avg)) {
                actualDahSpan.textContent = `${dahStats.avg} / ${dahStats.min} / ${dahStats.max}`;
            } else {
                actualDahSpan.textContent = `-- / -- / --`;
            }

            // Update the graphs
            updateStatGraph('ditGraphContainer', idealDit, ditStats);
            updateStatGraph('dahGraphContainer', idealDah, dahStats);
        }

        // --- Morse Timing Calculations (Ideal) ---
        // Calculates ideal timing elements based on WPM
        // Returns an array of { type: 'mark'/'space', duration: ms } if letter is provided
        // Returns an object { dit, dah, intraCharSpace, interCharSpace, wordSpace } if letter is empty
        function getIdealTiming(letter, wpm) {
            const upperLetter = letter ? letter.toUpperCase() : '';

            if (letter === ' ') {
                // For a space character, we might return just the word space duration
                // Or handle it differently depending on desired behavior. For now, empty.
                return [];
            }
            if (upperLetter && !ditdahMap[upperLetter]) {
                return []; // No timing for unknown chars
            }

            const ditDuration = 1200 / wpm; // Formula: T_dit = (60 * 1000) / (50 * wpm)
            const dahDuration = ditDuration * 3;
            const intraCharSpace = ditDuration; // Gap between dits/dahs in a letter
            const interCharSpace = ditDuration * 3;
            const wordSpace = ditDuration * 7; // Standard word space

            // If no letter provided, return the base timings object
            if (!upperLetter) {
                return { dit: ditDuration, dah: dahDuration, intraCharSpace, interCharSpace, wordSpace };
            }

            // If a letter is provided, calculate the specific timing array
            const patternString = ditdahMap[upperLetter];

            // If patternString is invalid (letter not in map), return empty array early
            if (!patternString) return [];

            let timings = [];
            let isFirstElement = true;
            for (let i = 0; i < patternString.length; i++) {
                const element = patternString[i];
                if (!isFirstElement) {
                    // Add intra-character space
                    timings.push({ type: 'space', duration: intraCharSpace });
                }
                if (element === '1') {
                    timings.push({ type: 'mark', duration: ditDuration });
                } else if (element === '2') {
                    timings.push({ type: 'mark', duration: dahDuration });
                }
                isFirstElement = false;
            }
            return timings;
        }

        // Renders a timing bar (ideal or actual) into the specified element
        function drawTimingBar(elementId, timings) {
            const container = document.getElementById(elementId);
            container.innerHTML = ''; // Clear previous bar

            // Calculate total duration for this specific timing array
            const ownTotalDuration = (timings && timings.length > 0) ? timings.reduce((sum, t) => sum + t.duration, 0) : 0;

            if (!timings || timings.length === 0 || ownTotalDuration <= 0) {
                return; // Nothing to draw
            }

            // Add a small minimum duration to prevent zero-width elements if totalDuration is very small
            const minElementDuration = 1; // Smallest duration to consider for scaling
            const effectiveTotalDuration = Math.max(ownTotalDuration, minElementDuration * timings.length);

            timings.forEach(timing => {
                const element = document.createElement('div');
                element.classList.add('timing-element');
                const isMark = timing.type === 'mark';
                element.classList.add(isMark ? 'timing-key-down' : 'timing-key-up');

                // Calculate width percentage, ensuring a minimum visible width if duration is tiny but non-zero
                const duration = Math.max(timing.duration, 0); // Ensure duration is not negative
                const percentage = (duration / effectiveTotalDuration) * 100;
                element.style.width = `${percentage}%`;
                // Add a minimum width in pixels for very short elements to remain visible
                if (percentage > 0 && percentage < 0.5) {
                     element.style.minWidth = '1px';
                }

                container.appendChild(element);
            });
        }

        // Initial display update (call after displays are updated initially)
        updateDisplays();
        updateStatsDisplay();
    </script>
</body>
</html>
